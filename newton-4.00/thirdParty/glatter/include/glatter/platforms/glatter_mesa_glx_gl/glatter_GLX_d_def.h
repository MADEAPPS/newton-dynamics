/*
Copyright 2018 Ioannis Makris

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// This file was generated by glatter.py script.



#ifdef GLATTER_GLX
#if defined(GLX_H)
#if defined(GLX_ARB_get_proc_address)
#ifndef glXGetProcAddressARB_defined
GLATTER_FBLOCK(return, GLX, extern, __GLXextFuncPtr, , glXGetProcAddressARB, (a0), (const GLubyte *a0))
GLATTER_INLINE_OR_NOT __GLXextFuncPtr glatter_glXGetProcAddressARB_debug(const GLubyte *a0, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetProcAddressARB, "(%p)", (void*)a0)
    __GLXextFuncPtr rval = glatter_glXGetProcAddressARB(a0);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetProcAddressARB_defined
#endif
#endif // defined(GLX_ARB_get_proc_address)
#if defined(GLX_ARB_render_texture)
GLATTER_FBLOCK(return, GLX, extern, Bool, , glXBindTexImageARB, (dpy, pbuffer, buffer), (Display *dpy, GLXPbuffer pbuffer, int buffer))
GLATTER_INLINE_OR_NOT Bool glatter_glXBindTexImageARB_debug(Display *dpy, GLXPbuffer pbuffer, int buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindTexImageARB, "(%p, %s, %d)", (void*)dpy, GET_PRS(pbuffer), (int)buffer)
    Bool rval = glatter_glXBindTexImageARB(dpy, pbuffer, buffer);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXBindTexImageARB_defined
GLATTER_FBLOCK(return, GLX, extern, Bool, , glXDrawableAttribARB, (dpy, draw, attribList), (Display *dpy, GLXDrawable draw, const int *attribList))
GLATTER_INLINE_OR_NOT Bool glatter_glXDrawableAttribARB_debug(Display *dpy, GLXDrawable draw, const int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDrawableAttribARB, "(%p, %s, %p)", (void*)dpy, GET_PRS(draw), (void*)attribList)
    Bool rval = glatter_glXDrawableAttribARB(dpy, draw, attribList);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXDrawableAttribARB_defined
GLATTER_FBLOCK(return, GLX, extern, Bool, , glXReleaseTexImageARB, (dpy, pbuffer, buffer), (Display *dpy, GLXPbuffer pbuffer, int buffer))
GLATTER_INLINE_OR_NOT Bool glatter_glXReleaseTexImageARB_debug(Display *dpy, GLXPbuffer pbuffer, int buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseTexImageARB, "(%p, %s, %d)", (void*)dpy, GET_PRS(pbuffer), (int)buffer)
    Bool rval = glatter_glXReleaseTexImageARB(dpy, pbuffer, buffer);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXReleaseTexImageARB_defined
#endif // defined(GLX_ARB_render_texture)
#if defined(GLX_MESA_swap_control)
#ifndef glXGetSwapIntervalMESA_defined
GLATTER_FBLOCK(return, GLX, extern, int, , glXGetSwapIntervalMESA, (), (void))
GLATTER_INLINE_OR_NOT int glatter_glXGetSwapIntervalMESA_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSwapIntervalMESA, "()")
    int rval = glatter_glXGetSwapIntervalMESA();
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetSwapIntervalMESA_defined
#endif
#ifndef glXSwapIntervalMESA_defined
GLATTER_FBLOCK(return, GLX, extern, int, , glXSwapIntervalMESA, (interval), (unsigned int interval))
GLATTER_INLINE_OR_NOT int glatter_glXSwapIntervalMESA_debug(unsigned int interval, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapIntervalMESA, "(%u)", (unsigned int)interval)
    int rval = glatter_glXSwapIntervalMESA(interval);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXSwapIntervalMESA_defined
#endif
#endif // defined(GLX_MESA_swap_control)
#if defined(GLX_MESA_swap_frame_usage)
GLATTER_FBLOCK(return, GLX, extern, int, , glXBeginFrameTrackingMESA, (dpy, drawable), (Display *dpy, GLXDrawable drawable))
GLATTER_INLINE_OR_NOT int glatter_glXBeginFrameTrackingMESA_debug(Display *dpy, GLXDrawable drawable, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBeginFrameTrackingMESA, "(%p, %s)", (void*)dpy, GET_PRS(drawable))
    int rval = glatter_glXBeginFrameTrackingMESA(dpy, drawable);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXBeginFrameTrackingMESA_defined
GLATTER_FBLOCK(return, GLX, extern, int, , glXEndFrameTrackingMESA, (dpy, drawable), (Display *dpy, GLXDrawable drawable))
GLATTER_INLINE_OR_NOT int glatter_glXEndFrameTrackingMESA_debug(Display *dpy, GLXDrawable drawable, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXEndFrameTrackingMESA, "(%p, %s)", (void*)dpy, GET_PRS(drawable))
    int rval = glatter_glXEndFrameTrackingMESA(dpy, drawable);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXEndFrameTrackingMESA_defined
GLATTER_FBLOCK(return, GLX, extern, int, , glXGetFrameUsageMESA, (dpy, drawable, usage), (Display *dpy, GLXDrawable drawable, float *usage))
GLATTER_INLINE_OR_NOT int glatter_glXGetFrameUsageMESA_debug(Display *dpy, GLXDrawable drawable, float *usage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFrameUsageMESA, "(%p, %s, %p)", (void*)dpy, GET_PRS(drawable), (void*)usage)
    int rval = glatter_glXGetFrameUsageMESA(dpy, drawable, usage);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetFrameUsageMESA_defined
GLATTER_FBLOCK(return, GLX, extern, int, , glXQueryFrameTrackingMESA, (dpy, drawable, swapCount, missedFrames, lastMissedUsage), (Display *dpy, GLXDrawable drawable, int64_t *swapCount, int64_t *missedFrames, float *lastMissedUsage))
GLATTER_INLINE_OR_NOT int glatter_glXQueryFrameTrackingMESA_debug(Display *dpy, GLXDrawable drawable, int64_t *swapCount, int64_t *missedFrames, float *lastMissedUsage, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryFrameTrackingMESA, "(%p, %s, %p, %p, %p)", (void*)dpy, GET_PRS(drawable), (void*)swapCount, (void*)missedFrames, (void*)lastMissedUsage)
    int rval = glatter_glXQueryFrameTrackingMESA(dpy, drawable, swapCount, missedFrames, lastMissedUsage);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryFrameTrackingMESA_defined
#endif // defined(GLX_MESA_swap_frame_usage)
#if defined(GLX_NV_vertex_array_range)
GLATTER_FBLOCK(return, GLX, extern, void *, , glXAllocateMemoryNV, (size, readfreq, writefreq, priority), (GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority))
GLATTER_INLINE_OR_NOT void * glatter_glXAllocateMemoryNV_debug(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXAllocateMemoryNV, "(%d, %f, %f, %f)", (int)size, (float)readfreq, (float)writefreq, (float)priority)
    void * rval = glatter_glXAllocateMemoryNV(size, readfreq, writefreq, priority);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXAllocateMemoryNV_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXFreeMemoryNV, (pointer), (GLvoid *pointer))
GLATTER_INLINE_OR_NOT void glatter_glXFreeMemoryNV_debug(GLvoid *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXFreeMemoryNV, "(%p)", (void*)pointer)
    glatter_glXFreeMemoryNV(pointer);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXFreeMemoryNV_defined
#endif // defined(GLX_NV_vertex_array_range)
#ifndef glXChooseFBConfig_defined
GLATTER_FBLOCK(return, GLX, extern, GLXFBConfig *, , glXChooseFBConfig, (dpy, screen, attribList, nitems), (Display *dpy, int screen, const int *attribList, int *nitems))
GLATTER_INLINE_OR_NOT GLXFBConfig * glatter_glXChooseFBConfig_debug(Display *dpy, int screen, const int *attribList, int *nitems, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXChooseFBConfig, "(%p, %d, %p, %p)", (void*)dpy, (int)screen, (void*)attribList, (void*)nitems)
    GLXFBConfig * rval = glatter_glXChooseFBConfig(dpy, screen, attribList, nitems);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXChooseFBConfig_defined
#endif
GLATTER_FBLOCK(return, GLX, extern, XVisualInfo*, , glXChooseVisual, (dpy, screen, attribList), (Display *dpy, int screen, int *attribList))
GLATTER_INLINE_OR_NOT XVisualInfo* glatter_glXChooseVisual_debug(Display *dpy, int screen, int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXChooseVisual, "(%p, %d, %p)", (void*)dpy, (int)screen, (void*)attribList)
    XVisualInfo* rval = glatter_glXChooseVisual(dpy, screen, attribList);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXChooseVisual_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXCopyContext, (dpy, src, dst, mask), (Display *dpy, GLXContext src, GLXContext dst, unsigned long mask))
GLATTER_INLINE_OR_NOT void glatter_glXCopyContext_debug(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCopyContext, "(%p, %p, %p, %lu)", (void*)dpy, (void*)src, (void*)dst, (unsigned long)mask)
    glatter_glXCopyContext(dpy, src, dst, mask);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXCopyContext_defined
GLATTER_FBLOCK(return, GLX, extern, GLXContext, , glXCreateContext, (dpy, vis, shareList, direct), (Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXCreateContext_debug(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateContext, "(%p, %p, %p, %s)", (void*)dpy, (void*)vis, (void*)shareList, GET_PRS(direct))
    GLXContext rval = glatter_glXCreateContext(dpy, vis, shareList, direct);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateContext_defined
GLATTER_FBLOCK(return, GLX, extern, GLXPixmap, , glXCreateGLXPixmap, (dpy, visual, pixmap), (Display *dpy, XVisualInfo *visual, Pixmap pixmap))
GLATTER_INLINE_OR_NOT GLXPixmap glatter_glXCreateGLXPixmap_debug(Display *dpy, XVisualInfo *visual, Pixmap pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXPixmap, "(%p, %p, %s)", (void*)dpy, (void*)visual, GET_PRS(pixmap))
    GLXPixmap rval = glatter_glXCreateGLXPixmap(dpy, visual, pixmap);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateGLXPixmap_defined
#ifndef glXCreateNewContext_defined
GLATTER_FBLOCK(return, GLX, extern, GLXContext, , glXCreateNewContext, (dpy, config, renderType, shareList, direct), (Display *dpy, GLXFBConfig config, int renderType, GLXContext shareList, Bool direct))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXCreateNewContext_debug(Display *dpy, GLXFBConfig config, int renderType, GLXContext shareList, Bool direct, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateNewContext, "(%p, %p, %d, %p, %s)", (void*)dpy, (void*)config, (int)renderType, (void*)shareList, GET_PRS(direct))
    GLXContext rval = glatter_glXCreateNewContext(dpy, config, renderType, shareList, direct);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateNewContext_defined
#endif
#ifndef glXCreatePbuffer_defined
GLATTER_FBLOCK(return, GLX, extern, GLXPbuffer, , glXCreatePbuffer, (dpy, config, attribList), (Display *dpy, GLXFBConfig config, const int *attribList))
GLATTER_INLINE_OR_NOT GLXPbuffer glatter_glXCreatePbuffer_debug(Display *dpy, GLXFBConfig config, const int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreatePbuffer, "(%p, %p, %p)", (void*)dpy, (void*)config, (void*)attribList)
    GLXPbuffer rval = glatter_glXCreatePbuffer(dpy, config, attribList);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreatePbuffer_defined
#endif
#ifndef glXCreatePixmap_defined
GLATTER_FBLOCK(return, GLX, extern, GLXPixmap, , glXCreatePixmap, (dpy, config, pixmap, attribList), (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attribList))
GLATTER_INLINE_OR_NOT GLXPixmap glatter_glXCreatePixmap_debug(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreatePixmap, "(%p, %p, %s, %p)", (void*)dpy, (void*)config, GET_PRS(pixmap), (void*)attribList)
    GLXPixmap rval = glatter_glXCreatePixmap(dpy, config, pixmap, attribList);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreatePixmap_defined
#endif
#ifndef glXCreateWindow_defined
GLATTER_FBLOCK(return, GLX, extern, GLXWindow, , glXCreateWindow, (dpy, config, win, attribList), (Display *dpy, GLXFBConfig config, Window win, const int *attribList))
GLATTER_INLINE_OR_NOT GLXWindow glatter_glXCreateWindow_debug(Display *dpy, GLXFBConfig config, Window win, const int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateWindow, "(%p, %p, %s, %p)", (void*)dpy, (void*)config, GET_PRS(win), (void*)attribList)
    GLXWindow rval = glatter_glXCreateWindow(dpy, config, win, attribList);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateWindow_defined
#endif
GLATTER_FBLOCK(, GLX, extern, void, , glXDestroyContext, (dpy, ctx), (Display *dpy, GLXContext ctx))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyContext_debug(Display *dpy, GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyContext, "(%p, %p)", (void*)dpy, (void*)ctx)
    glatter_glXDestroyContext(dpy, ctx);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyContext_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXDestroyGLXPixmap, (dpy, pixmap), (Display *dpy, GLXPixmap pixmap))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyGLXPixmap_debug(Display *dpy, GLXPixmap pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyGLXPixmap, "(%p, %s)", (void*)dpy, GET_PRS(pixmap))
    glatter_glXDestroyGLXPixmap(dpy, pixmap);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyGLXPixmap_defined
#ifndef glXDestroyPbuffer_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXDestroyPbuffer, (dpy, pbuf), (Display *dpy, GLXPbuffer pbuf))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyPbuffer_debug(Display *dpy, GLXPbuffer pbuf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyPbuffer, "(%p, %s)", (void*)dpy, GET_PRS(pbuf))
    glatter_glXDestroyPbuffer(dpy, pbuf);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyPbuffer_defined
#endif
#ifndef glXDestroyPixmap_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXDestroyPixmap, (dpy, pixmap), (Display *dpy, GLXPixmap pixmap))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyPixmap_debug(Display *dpy, GLXPixmap pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyPixmap, "(%p, %s)", (void*)dpy, GET_PRS(pixmap))
    glatter_glXDestroyPixmap(dpy, pixmap);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyPixmap_defined
#endif
#ifndef glXDestroyWindow_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXDestroyWindow, (dpy, window), (Display *dpy, GLXWindow window))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyWindow_debug(Display *dpy, GLXWindow window, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyWindow, "(%p, %s)", (void*)dpy, GET_PRS(window))
    glatter_glXDestroyWindow(dpy, window);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyWindow_defined
#endif
GLATTER_FBLOCK(return, GLX, extern, const char *, , glXGetClientString, (dpy, name), (Display *dpy, int name))
GLATTER_INLINE_OR_NOT const char * glatter_glXGetClientString_debug(Display *dpy, int name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetClientString, "(%p, %d)", (void*)dpy, (int)name)
    const char * rval = glatter_glXGetClientString(dpy, name);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetClientString_defined
GLATTER_FBLOCK(return, GLX, extern, int, , glXGetConfig, (dpy, visual, attrib, value), (Display *dpy, XVisualInfo *visual, int attrib, int *value))
GLATTER_INLINE_OR_NOT int glatter_glXGetConfig_debug(Display *dpy, XVisualInfo *visual, int attrib, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetConfig, "(%p, %p, %d, %p)", (void*)dpy, (void*)visual, (int)attrib, (void*)value)
    int rval = glatter_glXGetConfig(dpy, visual, attrib, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetConfig_defined
GLATTER_FBLOCK(return, GLX, extern, GLXContext, , glXGetCurrentContext, (), (void))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXGetCurrentContext_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentContext, "()")
    GLXContext rval = glatter_glXGetCurrentContext();
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetCurrentContext_defined
GLATTER_FBLOCK(return, GLX, extern, Display *, , glXGetCurrentDisplay, (), (void))
GLATTER_INLINE_OR_NOT Display * glatter_glXGetCurrentDisplay_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentDisplay, "()")
    Display * rval = glatter_glXGetCurrentDisplay();
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetCurrentDisplay_defined
GLATTER_FBLOCK(return, GLX, extern, GLXDrawable, , glXGetCurrentDrawable, (), (void))
GLATTER_INLINE_OR_NOT GLXDrawable glatter_glXGetCurrentDrawable_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentDrawable, "()")
    GLXDrawable rval = glatter_glXGetCurrentDrawable();
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetCurrentDrawable_defined
#ifndef glXGetCurrentReadDrawable_defined
GLATTER_FBLOCK(return, GLX, extern, GLXDrawable, , glXGetCurrentReadDrawable, (), (void))
GLATTER_INLINE_OR_NOT GLXDrawable glatter_glXGetCurrentReadDrawable_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentReadDrawable, "()")
    GLXDrawable rval = glatter_glXGetCurrentReadDrawable();
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetCurrentReadDrawable_defined
#endif
#ifndef glXGetFBConfigAttrib_defined
GLATTER_FBLOCK(return, GLX, extern, int, , glXGetFBConfigAttrib, (dpy, config, attribute, value), (Display *dpy, GLXFBConfig config, int attribute, int *value))
GLATTER_INLINE_OR_NOT int glatter_glXGetFBConfigAttrib_debug(Display *dpy, GLXFBConfig config, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigAttrib, "(%p, %p, %d, %p)", (void*)dpy, (void*)config, (int)attribute, (void*)value)
    int rval = glatter_glXGetFBConfigAttrib(dpy, config, attribute, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetFBConfigAttrib_defined
#endif
#ifndef glXGetFBConfigs_defined
GLATTER_FBLOCK(return, GLX, extern, GLXFBConfig *, , glXGetFBConfigs, (dpy, screen, nelements), (Display *dpy, int screen, int *nelements))
GLATTER_INLINE_OR_NOT GLXFBConfig * glatter_glXGetFBConfigs_debug(Display *dpy, int screen, int *nelements, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigs, "(%p, %d, %p)", (void*)dpy, (int)screen, (void*)nelements)
    GLXFBConfig * rval = glatter_glXGetFBConfigs(dpy, screen, nelements);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetFBConfigs_defined
#endif
#ifndef glXGetSelectedEvent_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXGetSelectedEvent, (dpy, drawable, mask), (Display *dpy, GLXDrawable drawable, unsigned long *mask))
GLATTER_INLINE_OR_NOT void glatter_glXGetSelectedEvent_debug(Display *dpy, GLXDrawable drawable, unsigned long *mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSelectedEvent, "(%p, %s, %p)", (void*)dpy, GET_PRS(drawable), (void*)mask)
    glatter_glXGetSelectedEvent(dpy, drawable, mask);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXGetSelectedEvent_defined
#endif
#ifndef glXGetVisualFromFBConfig_defined
GLATTER_FBLOCK(return, GLX, extern, XVisualInfo *, , glXGetVisualFromFBConfig, (dpy, config), (Display *dpy, GLXFBConfig config))
GLATTER_INLINE_OR_NOT XVisualInfo * glatter_glXGetVisualFromFBConfig_debug(Display *dpy, GLXFBConfig config, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVisualFromFBConfig, "(%p, %p)", (void*)dpy, (void*)config)
    XVisualInfo * rval = glatter_glXGetVisualFromFBConfig(dpy, config);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetVisualFromFBConfig_defined
#endif
GLATTER_FBLOCK(return, GLX, extern, Bool, , glXIsDirect, (dpy, ctx), (Display *dpy, GLXContext ctx))
GLATTER_INLINE_OR_NOT Bool glatter_glXIsDirect_debug(Display *dpy, GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXIsDirect, "(%p, %p)", (void*)dpy, (void*)ctx)
    Bool rval = glatter_glXIsDirect(dpy, ctx);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXIsDirect_defined
#ifndef glXMakeContextCurrent_defined
GLATTER_FBLOCK(return, GLX, extern, Bool, , glXMakeContextCurrent, (dpy, draw, read, ctx), (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx))
GLATTER_INLINE_OR_NOT Bool glatter_glXMakeContextCurrent_debug(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXMakeContextCurrent, "(%p, %s, %s, %p)", (void*)dpy, GET_PRS(draw), GET_PRS(read), (void*)ctx)
    Bool rval = glatter_glXMakeContextCurrent(dpy, draw, read, ctx);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXMakeContextCurrent_defined
#endif
GLATTER_FBLOCK(return, GLX, extern, Bool, , glXMakeCurrent, (dpy, drawable, ctx), (Display *dpy, GLXDrawable drawable, GLXContext ctx))
GLATTER_INLINE_OR_NOT Bool glatter_glXMakeCurrent_debug(Display *dpy, GLXDrawable drawable, GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXMakeCurrent, "(%p, %s, %p)", (void*)dpy, GET_PRS(drawable), (void*)ctx)
    Bool rval = glatter_glXMakeCurrent(dpy, drawable, ctx);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXMakeCurrent_defined
#ifndef glXQueryContext_defined
GLATTER_FBLOCK(return, GLX, extern, int, , glXQueryContext, (dpy, ctx, attribute, value), (Display *dpy, GLXContext ctx, int attribute, int *value))
GLATTER_INLINE_OR_NOT int glatter_glXQueryContext_debug(Display *dpy, GLXContext ctx, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryContext, "(%p, %p, %d, %p)", (void*)dpy, (void*)ctx, (int)attribute, (void*)value)
    int rval = glatter_glXQueryContext(dpy, ctx, attribute, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryContext_defined
#endif
#ifndef glXQueryDrawable_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXQueryDrawable, (dpy, draw, attribute, value), (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value))
GLATTER_INLINE_OR_NOT void glatter_glXQueryDrawable_debug(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryDrawable, "(%p, %s, %d, %p)", (void*)dpy, GET_PRS(draw), (int)attribute, (void*)value)
    glatter_glXQueryDrawable(dpy, draw, attribute, value);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXQueryDrawable_defined
#endif
GLATTER_FBLOCK(return, GLX, extern, Bool, , glXQueryExtension, (dpy, errorb, event), (Display *dpy, int *errorb, int *event))
GLATTER_INLINE_OR_NOT Bool glatter_glXQueryExtension_debug(Display *dpy, int *errorb, int *event, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryExtension, "(%p, %p, %p)", (void*)dpy, (void*)errorb, (void*)event)
    Bool rval = glatter_glXQueryExtension(dpy, errorb, event);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryExtension_defined
GLATTER_FBLOCK(return, GLX, extern, const char *, , glXQueryExtensionsString, (dpy, screen), (Display *dpy, int screen))
GLATTER_INLINE_OR_NOT const char * glatter_glXQueryExtensionsString_debug(Display *dpy, int screen, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryExtensionsString, "(%p, %d)", (void*)dpy, (int)screen)
    const char * rval = glatter_glXQueryExtensionsString(dpy, screen);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryExtensionsString_defined
GLATTER_FBLOCK(return, GLX, extern, const char *, , glXQueryServerString, (dpy, screen, name), (Display *dpy, int screen, int name))
GLATTER_INLINE_OR_NOT const char * glatter_glXQueryServerString_debug(Display *dpy, int screen, int name, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryServerString, "(%p, %d, %d)", (void*)dpy, (int)screen, (int)name)
    const char * rval = glatter_glXQueryServerString(dpy, screen, name);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryServerString_defined
GLATTER_FBLOCK(return, GLX, extern, Bool, , glXQueryVersion, (dpy, maj, min), (Display *dpy, int *maj, int *min))
GLATTER_INLINE_OR_NOT Bool glatter_glXQueryVersion_debug(Display *dpy, int *maj, int *min, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryVersion, "(%p, %p, %p)", (void*)dpy, (void*)maj, (void*)min)
    Bool rval = glatter_glXQueryVersion(dpy, maj, min);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryVersion_defined
#ifndef glXSelectEvent_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXSelectEvent, (dpy, drawable, mask), (Display *dpy, GLXDrawable drawable, unsigned long mask))
GLATTER_INLINE_OR_NOT void glatter_glXSelectEvent_debug(Display *dpy, GLXDrawable drawable, unsigned long mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSelectEvent, "(%p, %s, %lu)", (void*)dpy, GET_PRS(drawable), (unsigned long)mask)
    glatter_glXSelectEvent(dpy, drawable, mask);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXSelectEvent_defined
#endif
GLATTER_FBLOCK(, GLX, extern, void, , glXSwapBuffers, (dpy, drawable), (Display *dpy, GLXDrawable drawable))
GLATTER_INLINE_OR_NOT void glatter_glXSwapBuffers_debug(Display *dpy, GLXDrawable drawable, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapBuffers, "(%p, %s)", (void*)dpy, GET_PRS(drawable))
    glatter_glXSwapBuffers(dpy, drawable);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXSwapBuffers_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXUseXFont, (font, first, count, list), (Font font, int first, int count, int list))
GLATTER_INLINE_OR_NOT void glatter_glXUseXFont_debug(Font font, int first, int count, int list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXUseXFont, "(%s, %d, %d, %d)", GET_PRS(font), (int)first, (int)count, (int)list)
    glatter_glXUseXFont(font, first, count, list);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXUseXFont_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXWaitGL, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glXWaitGL_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXWaitGL, "()")
    glatter_glXWaitGL();
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXWaitGL_defined
GLATTER_FBLOCK(, GLX, extern, void, , glXWaitX, (), (void))
GLATTER_INLINE_OR_NOT void glatter_glXWaitX_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXWaitX, "()")
    glatter_glXWaitX();
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXWaitX_defined
#endif // defined(GLX_H)
#if defined(__glx_glxext_h_)
#if defined(GLX_AMD_gpu_association)
GLATTER_FBLOCK(, GLX, , void, , glXBlitContextFramebufferAMD, (dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))
GLATTER_INLINE_OR_NOT void glatter_glXBlitContextFramebufferAMD_debug(GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBlitContextFramebufferAMD, "(%p, %d, %d, %d, %d, %d, %d, %d, %d, %u, %s)", (void*)dstCtx, (int)srcX0, (int)srcY0, (int)srcX1, (int)srcY1, (int)dstX0, (int)dstY0, (int)dstX1, (int)dstY1, (unsigned int)mask, enum_to_string_GL(filter))
    glatter_glXBlitContextFramebufferAMD(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXBlitContextFramebufferAMD_defined
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateAssociatedContextAMD, (id, share_list), (unsigned int id, GLXContext share_list))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXCreateAssociatedContextAMD_debug(unsigned int id, GLXContext share_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateAssociatedContextAMD, "(%u, %p)", (unsigned int)id, (void*)share_list)
    GLXContext rval = glatter_glXCreateAssociatedContextAMD(id, share_list);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateAssociatedContextAMD_defined
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateAssociatedContextAttribsAMD, (id, share_context, attribList), (unsigned int id, GLXContext share_context, const int *attribList))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXCreateAssociatedContextAttribsAMD_debug(unsigned int id, GLXContext share_context, const int *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateAssociatedContextAttribsAMD, "(%u, %p, %p)", (unsigned int)id, (void*)share_context, (void*)attribList)
    GLXContext rval = glatter_glXCreateAssociatedContextAttribsAMD(id, share_context, attribList);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateAssociatedContextAttribsAMD_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXDeleteAssociatedContextAMD, (ctx), (GLXContext ctx))
GLATTER_INLINE_OR_NOT Bool glatter_glXDeleteAssociatedContextAMD_debug(GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDeleteAssociatedContextAMD, "(%p)", (void*)ctx)
    Bool rval = glatter_glXDeleteAssociatedContextAMD(ctx);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXDeleteAssociatedContextAMD_defined
GLATTER_FBLOCK(return, GLX, , unsigned int, , glXGetContextGPUIDAMD, (ctx), (GLXContext ctx))
GLATTER_INLINE_OR_NOT unsigned int glatter_glXGetContextGPUIDAMD_debug(GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetContextGPUIDAMD, "(%p)", (void*)ctx)
    unsigned int rval = glatter_glXGetContextGPUIDAMD(ctx);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetContextGPUIDAMD_defined
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXGetCurrentAssociatedContextAMD, (), (void))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXGetCurrentAssociatedContextAMD_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentAssociatedContextAMD, "()")
    GLXContext rval = glatter_glXGetCurrentAssociatedContextAMD();
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetCurrentAssociatedContextAMD_defined
GLATTER_FBLOCK(return, GLX, , unsigned int, , glXGetGPUIDsAMD, (maxCount, ids), (unsigned int maxCount, unsigned int *ids))
GLATTER_INLINE_OR_NOT unsigned int glatter_glXGetGPUIDsAMD_debug(unsigned int maxCount, unsigned int *ids, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetGPUIDsAMD, "(%u, %p)", (unsigned int)maxCount, (void*)ids)
    unsigned int rval = glatter_glXGetGPUIDsAMD(maxCount, ids);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetGPUIDsAMD_defined
GLATTER_FBLOCK(return, GLX, , int, , glXGetGPUInfoAMD, (id, property, dataType, size, data), (unsigned int id, int property, GLenum dataType, unsigned int size, void *data))
GLATTER_INLINE_OR_NOT int glatter_glXGetGPUInfoAMD_debug(unsigned int id, int property, GLenum dataType, unsigned int size, void *data, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetGPUInfoAMD, "(%u, %d, %s, %u, %p)", (unsigned int)id, (int)property, enum_to_string_GL(dataType), (unsigned int)size, (void*)data)
    int rval = glatter_glXGetGPUInfoAMD(id, property, dataType, size, data);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetGPUInfoAMD_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXMakeAssociatedContextCurrentAMD, (ctx), (GLXContext ctx))
GLATTER_INLINE_OR_NOT Bool glatter_glXMakeAssociatedContextCurrentAMD_debug(GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXMakeAssociatedContextCurrentAMD, "(%p)", (void*)ctx)
    Bool rval = glatter_glXMakeAssociatedContextCurrentAMD(ctx);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXMakeAssociatedContextCurrentAMD_defined
#endif // defined(GLX_AMD_gpu_association)
#if defined(GLX_ARB_create_context)
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateContextAttribsARB, (dpy, config, share_context, direct, attrib_list), (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXCreateContextAttribsARB_debug(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateContextAttribsARB, "(%p, %p, %p, %s, %p)", (void*)dpy, (void*)config, (void*)share_context, GET_PRS(direct), (void*)attrib_list)
    GLXContext rval = glatter_glXCreateContextAttribsARB(dpy, config, share_context, direct, attrib_list);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateContextAttribsARB_defined
#endif // defined(GLX_ARB_create_context)
#if defined(GLX_ARB_get_proc_address)
#ifndef glXGetProcAddressARB_defined
GLATTER_FBLOCK(return, GLX, , __GLXextFuncPtr, , glXGetProcAddressARB, (procName), (const GLubyte *procName))
GLATTER_INLINE_OR_NOT __GLXextFuncPtr glatter_glXGetProcAddressARB_debug(const GLubyte *procName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetProcAddressARB, "(%p)", (void*)procName)
    __GLXextFuncPtr rval = glatter_glXGetProcAddressARB(procName);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetProcAddressARB_defined
#endif
#endif // defined(GLX_ARB_get_proc_address)
#if defined(GLX_EXT_import_context)
GLATTER_FBLOCK(, GLX, , void, , glXFreeContextEXT, (dpy, context), (Display *dpy, GLXContext context))
GLATTER_INLINE_OR_NOT void glatter_glXFreeContextEXT_debug(Display *dpy, GLXContext context, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXFreeContextEXT, "(%p, %p)", (void*)dpy, (void*)context)
    glatter_glXFreeContextEXT(dpy, context);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXFreeContextEXT_defined
GLATTER_FBLOCK(return, GLX, , GLXContextID, , glXGetContextIDEXT, (context), (const GLXContext context))
GLATTER_INLINE_OR_NOT GLXContextID glatter_glXGetContextIDEXT_debug(const GLXContext context, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetContextIDEXT, "(%s)", GET_PRS(context))
    GLXContextID rval = glatter_glXGetContextIDEXT(context);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetContextIDEXT_defined
GLATTER_FBLOCK(return, GLX, , Display *, , glXGetCurrentDisplayEXT, (), (void))
GLATTER_INLINE_OR_NOT Display * glatter_glXGetCurrentDisplayEXT_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentDisplayEXT, "()")
    Display * rval = glatter_glXGetCurrentDisplayEXT();
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetCurrentDisplayEXT_defined
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXImportContextEXT, (dpy, contextID), (Display *dpy, GLXContextID contextID))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXImportContextEXT_debug(Display *dpy, GLXContextID contextID, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXImportContextEXT, "(%p, %s)", (void*)dpy, GET_PRS(contextID))
    GLXContext rval = glatter_glXImportContextEXT(dpy, contextID);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXImportContextEXT_defined
GLATTER_FBLOCK(return, GLX, , int, , glXQueryContextInfoEXT, (dpy, context, attribute, value), (Display *dpy, GLXContext context, int attribute, int *value))
GLATTER_INLINE_OR_NOT int glatter_glXQueryContextInfoEXT_debug(Display *dpy, GLXContext context, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryContextInfoEXT, "(%p, %p, %d, %p)", (void*)dpy, (void*)context, (int)attribute, (void*)value)
    int rval = glatter_glXQueryContextInfoEXT(dpy, context, attribute, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryContextInfoEXT_defined
#endif // defined(GLX_EXT_import_context)
#if defined(GLX_EXT_swap_control)
GLATTER_FBLOCK(, GLX, , void, , glXSwapIntervalEXT, (dpy, drawable, interval), (Display *dpy, GLXDrawable drawable, int interval))
GLATTER_INLINE_OR_NOT void glatter_glXSwapIntervalEXT_debug(Display *dpy, GLXDrawable drawable, int interval, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapIntervalEXT, "(%p, %s, %d)", (void*)dpy, GET_PRS(drawable), (int)interval)
    glatter_glXSwapIntervalEXT(dpy, drawable, interval);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXSwapIntervalEXT_defined
#endif // defined(GLX_EXT_swap_control)
#if defined(GLX_EXT_texture_from_pixmap)
GLATTER_FBLOCK(, GLX, , void, , glXBindTexImageEXT, (dpy, drawable, buffer, attrib_list), (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list))
GLATTER_INLINE_OR_NOT void glatter_glXBindTexImageEXT_debug(Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindTexImageEXT, "(%p, %s, %d, %p)", (void*)dpy, GET_PRS(drawable), (int)buffer, (void*)attrib_list)
    glatter_glXBindTexImageEXT(dpy, drawable, buffer, attrib_list);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXBindTexImageEXT_defined
GLATTER_FBLOCK(, GLX, , void, , glXReleaseTexImageEXT, (dpy, drawable, buffer), (Display *dpy, GLXDrawable drawable, int buffer))
GLATTER_INLINE_OR_NOT void glatter_glXReleaseTexImageEXT_debug(Display *dpy, GLXDrawable drawable, int buffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseTexImageEXT, "(%p, %s, %d)", (void*)dpy, GET_PRS(drawable), (int)buffer)
    glatter_glXReleaseTexImageEXT(dpy, drawable, buffer);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXReleaseTexImageEXT_defined
#endif // defined(GLX_EXT_texture_from_pixmap)
#if defined(GLX_MESA_agp_offset)
GLATTER_FBLOCK(return, GLX, , unsigned int, , glXGetAGPOffsetMESA, (pointer), (const void *pointer))
GLATTER_INLINE_OR_NOT unsigned int glatter_glXGetAGPOffsetMESA_debug(const void *pointer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetAGPOffsetMESA, "(%p)", (void*)pointer)
    unsigned int rval = glatter_glXGetAGPOffsetMESA(pointer);
    GLATTER_RBLOCK("%u\n", (unsigned int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetAGPOffsetMESA_defined
#endif // defined(GLX_MESA_agp_offset)
#if defined(GLX_MESA_copy_sub_buffer)
GLATTER_FBLOCK(, GLX, , void, , glXCopySubBufferMESA, (dpy, drawable, x, y, width, height), (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height))
GLATTER_INLINE_OR_NOT void glatter_glXCopySubBufferMESA_debug(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCopySubBufferMESA, "(%p, %s, %d, %d, %d, %d)", (void*)dpy, GET_PRS(drawable), (int)x, (int)y, (int)width, (int)height)
    glatter_glXCopySubBufferMESA(dpy, drawable, x, y, width, height);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXCopySubBufferMESA_defined
#endif // defined(GLX_MESA_copy_sub_buffer)
#if defined(GLX_MESA_pixmap_colormap)
GLATTER_FBLOCK(return, GLX, , GLXPixmap, , glXCreateGLXPixmapMESA, (dpy, visual, pixmap, cmap), (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap))
GLATTER_INLINE_OR_NOT GLXPixmap glatter_glXCreateGLXPixmapMESA_debug(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXPixmapMESA, "(%p, %p, %s, %s)", (void*)dpy, (void*)visual, GET_PRS(pixmap), GET_PRS(cmap))
    GLXPixmap rval = glatter_glXCreateGLXPixmapMESA(dpy, visual, pixmap, cmap);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateGLXPixmapMESA_defined
#endif // defined(GLX_MESA_pixmap_colormap)
#if defined(GLX_MESA_query_renderer)
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryCurrentRendererIntegerMESA, (attribute, value), (int attribute, unsigned int *value))
GLATTER_INLINE_OR_NOT Bool glatter_glXQueryCurrentRendererIntegerMESA_debug(int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryCurrentRendererIntegerMESA, "(%d, %p)", (int)attribute, (void*)value)
    Bool rval = glatter_glXQueryCurrentRendererIntegerMESA(attribute, value);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryCurrentRendererIntegerMESA_defined
GLATTER_FBLOCK(return, GLX, , const char *, , glXQueryCurrentRendererStringMESA, (attribute), (int attribute))
GLATTER_INLINE_OR_NOT const char * glatter_glXQueryCurrentRendererStringMESA_debug(int attribute, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryCurrentRendererStringMESA, "(%d)", (int)attribute)
    const char * rval = glatter_glXQueryCurrentRendererStringMESA(attribute);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryCurrentRendererStringMESA_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryRendererIntegerMESA, (dpy, screen, renderer, attribute, value), (Display *dpy, int screen, int renderer, int attribute, unsigned int *value))
GLATTER_INLINE_OR_NOT Bool glatter_glXQueryRendererIntegerMESA_debug(Display *dpy, int screen, int renderer, int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryRendererIntegerMESA, "(%p, %d, %d, %d, %p)", (void*)dpy, (int)screen, (int)renderer, (int)attribute, (void*)value)
    Bool rval = glatter_glXQueryRendererIntegerMESA(dpy, screen, renderer, attribute, value);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryRendererIntegerMESA_defined
GLATTER_FBLOCK(return, GLX, , const char *, , glXQueryRendererStringMESA, (dpy, screen, renderer, attribute), (Display *dpy, int screen, int renderer, int attribute))
GLATTER_INLINE_OR_NOT const char * glatter_glXQueryRendererStringMESA_debug(Display *dpy, int screen, int renderer, int attribute, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryRendererStringMESA, "(%p, %d, %d, %d)", (void*)dpy, (int)screen, (int)renderer, (int)attribute)
    const char * rval = glatter_glXQueryRendererStringMESA(dpy, screen, renderer, attribute);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryRendererStringMESA_defined
#endif // defined(GLX_MESA_query_renderer)
#if defined(GLX_MESA_release_buffers)
GLATTER_FBLOCK(return, GLX, , Bool, , glXReleaseBuffersMESA, (dpy, drawable), (Display *dpy, GLXDrawable drawable))
GLATTER_INLINE_OR_NOT Bool glatter_glXReleaseBuffersMESA_debug(Display *dpy, GLXDrawable drawable, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseBuffersMESA, "(%p, %s)", (void*)dpy, GET_PRS(drawable))
    Bool rval = glatter_glXReleaseBuffersMESA(dpy, drawable);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXReleaseBuffersMESA_defined
#endif // defined(GLX_MESA_release_buffers)
#if defined(GLX_MESA_set_3dfx_mode)
GLATTER_FBLOCK(return, GLX, , Bool, , glXSet3DfxModeMESA, (mode), (int mode))
GLATTER_INLINE_OR_NOT Bool glatter_glXSet3DfxModeMESA_debug(int mode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSet3DfxModeMESA, "(%d)", (int)mode)
    Bool rval = glatter_glXSet3DfxModeMESA(mode);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXSet3DfxModeMESA_defined
#endif // defined(GLX_MESA_set_3dfx_mode)
#if defined(GLX_MESA_swap_control)
#ifndef glXGetSwapIntervalMESA_defined
GLATTER_FBLOCK(return, GLX, , int, , glXGetSwapIntervalMESA, (), (void))
GLATTER_INLINE_OR_NOT int glatter_glXGetSwapIntervalMESA_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSwapIntervalMESA, "()")
    int rval = glatter_glXGetSwapIntervalMESA();
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetSwapIntervalMESA_defined
#endif
#ifndef glXSwapIntervalMESA_defined
GLATTER_FBLOCK(return, GLX, , int, , glXSwapIntervalMESA, (interval), (unsigned int interval))
GLATTER_INLINE_OR_NOT int glatter_glXSwapIntervalMESA_debug(unsigned int interval, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapIntervalMESA, "(%u)", (unsigned int)interval)
    int rval = glatter_glXSwapIntervalMESA(interval);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXSwapIntervalMESA_defined
#endif
#endif // defined(GLX_MESA_swap_control)
#if defined(GLX_NV_copy_buffer)
GLATTER_FBLOCK(, GLX, , void, , glXCopyBufferSubDataNV, (dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size), (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glXCopyBufferSubDataNV_debug(Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCopyBufferSubDataNV, "(%p, %p, %p, %s, %s, %s, %s, %s)", (void*)dpy, (void*)readCtx, (void*)writeCtx, enum_to_string_GL(readTarget), enum_to_string_GL(writeTarget), GET_PRS(readOffset), GET_PRS(writeOffset), GET_PRS(size))
    glatter_glXCopyBufferSubDataNV(dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXCopyBufferSubDataNV_defined
GLATTER_FBLOCK(, GLX, , void, , glXNamedCopyBufferSubDataNV, (dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size), (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size))
GLATTER_INLINE_OR_NOT void glatter_glXNamedCopyBufferSubDataNV_debug(Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXNamedCopyBufferSubDataNV, "(%p, %p, %p, %u, %u, %s, %s, %s)", (void*)dpy, (void*)readCtx, (void*)writeCtx, (unsigned int)readBuffer, (unsigned int)writeBuffer, GET_PRS(readOffset), GET_PRS(writeOffset), GET_PRS(size))
    glatter_glXNamedCopyBufferSubDataNV(dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXNamedCopyBufferSubDataNV_defined
#endif // defined(GLX_NV_copy_buffer)
#if defined(GLX_NV_copy_image)
GLATTER_FBLOCK(, GLX, , void, , glXCopyImageSubDataNV, (dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth), (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth))
GLATTER_INLINE_OR_NOT void glatter_glXCopyImageSubDataNV_debug(Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCopyImageSubDataNV, "(%p, %p, %u, %s, %d, %d, %d, %d, %p, %u, %s, %d, %d, %d, %d, %d, %d, %d)", (void*)dpy, (void*)srcCtx, (unsigned int)srcName, enum_to_string_GL(srcTarget), (int)srcLevel, (int)srcX, (int)srcY, (int)srcZ, (void*)dstCtx, (unsigned int)dstName, enum_to_string_GL(dstTarget), (int)dstLevel, (int)dstX, (int)dstY, (int)dstZ, (int)width, (int)height, (int)depth)
    glatter_glXCopyImageSubDataNV(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXCopyImageSubDataNV_defined
#endif // defined(GLX_NV_copy_image)
#if defined(GLX_NV_delay_before_swap)
GLATTER_FBLOCK(return, GLX, , Bool, , glXDelayBeforeSwapNV, (dpy, drawable, seconds), (Display *dpy, GLXDrawable drawable, GLfloat seconds))
GLATTER_INLINE_OR_NOT Bool glatter_glXDelayBeforeSwapNV_debug(Display *dpy, GLXDrawable drawable, GLfloat seconds, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDelayBeforeSwapNV, "(%p, %s, %f)", (void*)dpy, GET_PRS(drawable), (float)seconds)
    Bool rval = glatter_glXDelayBeforeSwapNV(dpy, drawable, seconds);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXDelayBeforeSwapNV_defined
#endif // defined(GLX_NV_delay_before_swap)
#if defined(GLX_NV_present_video)
GLATTER_FBLOCK(return, GLX, , int, , glXBindVideoDeviceNV, (dpy, video_slot, video_device, attrib_list), (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list))
GLATTER_INLINE_OR_NOT int glatter_glXBindVideoDeviceNV_debug(Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindVideoDeviceNV, "(%p, %u, %u, %p)", (void*)dpy, (unsigned int)video_slot, (unsigned int)video_device, (void*)attrib_list)
    int rval = glatter_glXBindVideoDeviceNV(dpy, video_slot, video_device, attrib_list);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXBindVideoDeviceNV_defined
GLATTER_FBLOCK(return, GLX, , unsigned int *, , glXEnumerateVideoDevicesNV, (dpy, screen, nelements), (Display *dpy, int screen, int *nelements))
GLATTER_INLINE_OR_NOT unsigned int * glatter_glXEnumerateVideoDevicesNV_debug(Display *dpy, int screen, int *nelements, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXEnumerateVideoDevicesNV, "(%p, %d, %p)", (void*)dpy, (int)screen, (void*)nelements)
    unsigned int * rval = glatter_glXEnumerateVideoDevicesNV(dpy, screen, nelements);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXEnumerateVideoDevicesNV_defined
#endif // defined(GLX_NV_present_video)
#if defined(GLX_NV_swap_group)
GLATTER_FBLOCK(return, GLX, , Bool, , glXBindSwapBarrierNV, (dpy, group, barrier), (Display *dpy, GLuint group, GLuint barrier))
GLATTER_INLINE_OR_NOT Bool glatter_glXBindSwapBarrierNV_debug(Display *dpy, GLuint group, GLuint barrier, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindSwapBarrierNV, "(%p, %u, %u)", (void*)dpy, (unsigned int)group, (unsigned int)barrier)
    Bool rval = glatter_glXBindSwapBarrierNV(dpy, group, barrier);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXBindSwapBarrierNV_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXJoinSwapGroupNV, (dpy, drawable, group), (Display *dpy, GLXDrawable drawable, GLuint group))
GLATTER_INLINE_OR_NOT Bool glatter_glXJoinSwapGroupNV_debug(Display *dpy, GLXDrawable drawable, GLuint group, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXJoinSwapGroupNV, "(%p, %s, %u)", (void*)dpy, GET_PRS(drawable), (unsigned int)group)
    Bool rval = glatter_glXJoinSwapGroupNV(dpy, drawable, group);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXJoinSwapGroupNV_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryFrameCountNV, (dpy, screen, count), (Display *dpy, int screen, GLuint *count))
GLATTER_INLINE_OR_NOT Bool glatter_glXQueryFrameCountNV_debug(Display *dpy, int screen, GLuint *count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryFrameCountNV, "(%p, %d, %p)", (void*)dpy, (int)screen, (void*)count)
    Bool rval = glatter_glXQueryFrameCountNV(dpy, screen, count);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryFrameCountNV_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryMaxSwapGroupsNV, (dpy, screen, maxGroups, maxBarriers), (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers))
GLATTER_INLINE_OR_NOT Bool glatter_glXQueryMaxSwapGroupsNV_debug(Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryMaxSwapGroupsNV, "(%p, %d, %p, %p)", (void*)dpy, (int)screen, (void*)maxGroups, (void*)maxBarriers)
    Bool rval = glatter_glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups, maxBarriers);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryMaxSwapGroupsNV_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXQuerySwapGroupNV, (dpy, drawable, group, barrier), (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier))
GLATTER_INLINE_OR_NOT Bool glatter_glXQuerySwapGroupNV_debug(Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQuerySwapGroupNV, "(%p, %s, %p, %p)", (void*)dpy, GET_PRS(drawable), (void*)group, (void*)barrier)
    Bool rval = glatter_glXQuerySwapGroupNV(dpy, drawable, group, barrier);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQuerySwapGroupNV_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXResetFrameCountNV, (dpy, screen), (Display *dpy, int screen))
GLATTER_INLINE_OR_NOT Bool glatter_glXResetFrameCountNV_debug(Display *dpy, int screen, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXResetFrameCountNV, "(%p, %d)", (void*)dpy, (int)screen)
    Bool rval = glatter_glXResetFrameCountNV(dpy, screen);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXResetFrameCountNV_defined
#endif // defined(GLX_NV_swap_group)
#if defined(GLX_NV_video_capture)
GLATTER_FBLOCK(return, GLX, , int, , glXBindVideoCaptureDeviceNV, (dpy, video_capture_slot, device), (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device))
GLATTER_INLINE_OR_NOT int glatter_glXBindVideoCaptureDeviceNV_debug(Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindVideoCaptureDeviceNV, "(%p, %u, %s)", (void*)dpy, (unsigned int)video_capture_slot, GET_PRS(device))
    int rval = glatter_glXBindVideoCaptureDeviceNV(dpy, video_capture_slot, device);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXBindVideoCaptureDeviceNV_defined
GLATTER_FBLOCK(return, GLX, , GLXVideoCaptureDeviceNV *, , glXEnumerateVideoCaptureDevicesNV, (dpy, screen, nelements), (Display *dpy, int screen, int *nelements))
GLATTER_INLINE_OR_NOT GLXVideoCaptureDeviceNV * glatter_glXEnumerateVideoCaptureDevicesNV_debug(Display *dpy, int screen, int *nelements, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXEnumerateVideoCaptureDevicesNV, "(%p, %d, %p)", (void*)dpy, (int)screen, (void*)nelements)
    GLXVideoCaptureDeviceNV * rval = glatter_glXEnumerateVideoCaptureDevicesNV(dpy, screen, nelements);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXEnumerateVideoCaptureDevicesNV_defined
GLATTER_FBLOCK(, GLX, , void, , glXLockVideoCaptureDeviceNV, (dpy, device), (Display *dpy, GLXVideoCaptureDeviceNV device))
GLATTER_INLINE_OR_NOT void glatter_glXLockVideoCaptureDeviceNV_debug(Display *dpy, GLXVideoCaptureDeviceNV device, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXLockVideoCaptureDeviceNV, "(%p, %s)", (void*)dpy, GET_PRS(device))
    glatter_glXLockVideoCaptureDeviceNV(dpy, device);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXLockVideoCaptureDeviceNV_defined
GLATTER_FBLOCK(return, GLX, , int, , glXQueryVideoCaptureDeviceNV, (dpy, device, attribute, value), (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value))
GLATTER_INLINE_OR_NOT int glatter_glXQueryVideoCaptureDeviceNV_debug(Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryVideoCaptureDeviceNV, "(%p, %s, %d, %p)", (void*)dpy, GET_PRS(device), (int)attribute, (void*)value)
    int rval = glatter_glXQueryVideoCaptureDeviceNV(dpy, device, attribute, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryVideoCaptureDeviceNV_defined
GLATTER_FBLOCK(, GLX, , void, , glXReleaseVideoCaptureDeviceNV, (dpy, device), (Display *dpy, GLXVideoCaptureDeviceNV device))
GLATTER_INLINE_OR_NOT void glatter_glXReleaseVideoCaptureDeviceNV_debug(Display *dpy, GLXVideoCaptureDeviceNV device, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseVideoCaptureDeviceNV, "(%p, %s)", (void*)dpy, GET_PRS(device))
    glatter_glXReleaseVideoCaptureDeviceNV(dpy, device);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXReleaseVideoCaptureDeviceNV_defined
#endif // defined(GLX_NV_video_capture)
#if defined(GLX_NV_video_out)
GLATTER_FBLOCK(return, GLX, , int, , glXBindVideoImageNV, (dpy, VideoDevice, pbuf, iVideoBuffer), (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer))
GLATTER_INLINE_OR_NOT int glatter_glXBindVideoImageNV_debug(Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindVideoImageNV, "(%p, %u, %s, %d)", (void*)dpy, (unsigned int)VideoDevice, GET_PRS(pbuf), (int)iVideoBuffer)
    int rval = glatter_glXBindVideoImageNV(dpy, VideoDevice, pbuf, iVideoBuffer);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXBindVideoImageNV_defined
GLATTER_FBLOCK(return, GLX, , int, , glXGetVideoDeviceNV, (dpy, screen, numVideoDevices, pVideoDevice), (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice))
GLATTER_INLINE_OR_NOT int glatter_glXGetVideoDeviceNV_debug(Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVideoDeviceNV, "(%p, %d, %d, %p)", (void*)dpy, (int)screen, (int)numVideoDevices, (void*)pVideoDevice)
    int rval = glatter_glXGetVideoDeviceNV(dpy, screen, numVideoDevices, pVideoDevice);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetVideoDeviceNV_defined
GLATTER_FBLOCK(return, GLX, , int, , glXGetVideoInfoNV, (dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo), (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo))
GLATTER_INLINE_OR_NOT int glatter_glXGetVideoInfoNV_debug(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVideoInfoNV, "(%p, %d, %u, %p, %p)", (void*)dpy, (int)screen, (unsigned int)VideoDevice, (void*)pulCounterOutputPbuffer, (void*)pulCounterOutputVideo)
    int rval = glatter_glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetVideoInfoNV_defined
GLATTER_FBLOCK(return, GLX, , int, , glXReleaseVideoDeviceNV, (dpy, screen, VideoDevice), (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice))
GLATTER_INLINE_OR_NOT int glatter_glXReleaseVideoDeviceNV_debug(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseVideoDeviceNV, "(%p, %d, %u)", (void*)dpy, (int)screen, (unsigned int)VideoDevice)
    int rval = glatter_glXReleaseVideoDeviceNV(dpy, screen, VideoDevice);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXReleaseVideoDeviceNV_defined
GLATTER_FBLOCK(return, GLX, , int, , glXReleaseVideoImageNV, (dpy, pbuf), (Display *dpy, GLXPbuffer pbuf))
GLATTER_INLINE_OR_NOT int glatter_glXReleaseVideoImageNV_debug(Display *dpy, GLXPbuffer pbuf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXReleaseVideoImageNV, "(%p, %s)", (void*)dpy, GET_PRS(pbuf))
    int rval = glatter_glXReleaseVideoImageNV(dpy, pbuf);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXReleaseVideoImageNV_defined
GLATTER_FBLOCK(return, GLX, , int, , glXSendPbufferToVideoNV, (dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock), (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock))
GLATTER_INLINE_OR_NOT int glatter_glXSendPbufferToVideoNV_debug(Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSendPbufferToVideoNV, "(%p, %s, %d, %p, %u)", (void*)dpy, GET_PRS(pbuf), (int)iBufferType, (void*)pulCounterPbuffer, (unsigned char)bBlock)
    int rval = glatter_glXSendPbufferToVideoNV(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXSendPbufferToVideoNV_defined
#endif // defined(GLX_NV_video_out)
#if defined(GLX_OML_sync_control)
GLATTER_FBLOCK(return, GLX, , Bool, , glXGetMscRateOML, (dpy, drawable, numerator, denominator), (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator))
GLATTER_INLINE_OR_NOT Bool glatter_glXGetMscRateOML_debug(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetMscRateOML, "(%p, %s, %p, %p)", (void*)dpy, GET_PRS(drawable), (void*)numerator, (void*)denominator)
    Bool rval = glatter_glXGetMscRateOML(dpy, drawable, numerator, denominator);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetMscRateOML_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXGetSyncValuesOML, (dpy, drawable, ust, msc, sbc), (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc))
GLATTER_INLINE_OR_NOT Bool glatter_glXGetSyncValuesOML_debug(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSyncValuesOML, "(%p, %s, %p, %p, %p)", (void*)dpy, GET_PRS(drawable), (void*)ust, (void*)msc, (void*)sbc)
    Bool rval = glatter_glXGetSyncValuesOML(dpy, drawable, ust, msc, sbc);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetSyncValuesOML_defined
GLATTER_FBLOCK(return, GLX, , int64_t, , glXSwapBuffersMscOML, (dpy, drawable, target_msc, divisor, remainder), (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder))
GLATTER_INLINE_OR_NOT int64_t glatter_glXSwapBuffersMscOML_debug(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapBuffersMscOML, "(%p, %s, %" PRId64 ", %" PRId64 ", %" PRId64 ")", (void*)dpy, GET_PRS(drawable), (int64_t)target_msc, (int64_t)divisor, (int64_t)remainder)
    int64_t rval = glatter_glXSwapBuffersMscOML(dpy, drawable, target_msc, divisor, remainder);
    GLATTER_RBLOCK("%" PRId64 "\n", (int64_t)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXSwapBuffersMscOML_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXWaitForMscOML, (dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc), (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc))
GLATTER_INLINE_OR_NOT Bool glatter_glXWaitForMscOML_debug(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXWaitForMscOML, "(%p, %s, %" PRId64 ", %" PRId64 ", %" PRId64 ", %p, %p, %p)", (void*)dpy, GET_PRS(drawable), (int64_t)target_msc, (int64_t)divisor, (int64_t)remainder, (void*)ust, (void*)msc, (void*)sbc)
    Bool rval = glatter_glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXWaitForMscOML_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXWaitForSbcOML, (dpy, drawable, target_sbc, ust, msc, sbc), (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc))
GLATTER_INLINE_OR_NOT Bool glatter_glXWaitForSbcOML_debug(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXWaitForSbcOML, "(%p, %s, %" PRId64 ", %p, %p, %p)", (void*)dpy, GET_PRS(drawable), (int64_t)target_sbc, (void*)ust, (void*)msc, (void*)sbc)
    Bool rval = glatter_glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc, sbc);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXWaitForSbcOML_defined
#endif // defined(GLX_OML_sync_control)
#if defined(GLX_SGIX_dmbuffer)
#if defined(_DM_BUFFER_H_)
GLATTER_FBLOCK(return, GLX, , Bool, , glXAssociateDMPbufferSGIX, (dpy, pbuffer, params, dmbuffer), (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer))
GLATTER_INLINE_OR_NOT Bool glatter_glXAssociateDMPbufferSGIX_debug(Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXAssociateDMPbufferSGIX, "(%p, %s, %p, %s)", (void*)dpy, GET_PRS(pbuffer), (void*)params, GET_PRS(dmbuffer))
    Bool rval = glatter_glXAssociateDMPbufferSGIX(dpy, pbuffer, params, dmbuffer);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXAssociateDMPbufferSGIX_defined
#endif // defined(_DM_BUFFER_H_)
#endif // defined(GLX_SGIX_dmbuffer)
#if defined(GLX_SGIX_fbconfig)
GLATTER_FBLOCK(return, GLX, , GLXFBConfigSGIX *, , glXChooseFBConfigSGIX, (dpy, screen, attrib_list, nelements), (Display *dpy, int screen, int *attrib_list, int *nelements))
GLATTER_INLINE_OR_NOT GLXFBConfigSGIX * glatter_glXChooseFBConfigSGIX_debug(Display *dpy, int screen, int *attrib_list, int *nelements, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXChooseFBConfigSGIX, "(%p, %d, %p, %p)", (void*)dpy, (int)screen, (void*)attrib_list, (void*)nelements)
    GLXFBConfigSGIX * rval = glatter_glXChooseFBConfigSGIX(dpy, screen, attrib_list, nelements);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXChooseFBConfigSGIX_defined
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateContextWithConfigSGIX, (dpy, config, render_type, share_list, direct), (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXCreateContextWithConfigSGIX_debug(Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateContextWithConfigSGIX, "(%p, %p, %d, %p, %s)", (void*)dpy, (void*)config, (int)render_type, (void*)share_list, GET_PRS(direct))
    GLXContext rval = glatter_glXCreateContextWithConfigSGIX(dpy, config, render_type, share_list, direct);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateContextWithConfigSGIX_defined
GLATTER_FBLOCK(return, GLX, , GLXPixmap, , glXCreateGLXPixmapWithConfigSGIX, (dpy, config, pixmap), (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap))
GLATTER_INLINE_OR_NOT GLXPixmap glatter_glXCreateGLXPixmapWithConfigSGIX_debug(Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXPixmapWithConfigSGIX, "(%p, %p, %s)", (void*)dpy, (void*)config, GET_PRS(pixmap))
    GLXPixmap rval = glatter_glXCreateGLXPixmapWithConfigSGIX(dpy, config, pixmap);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateGLXPixmapWithConfigSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXGetFBConfigAttribSGIX, (dpy, config, attribute, value), (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value))
GLATTER_INLINE_OR_NOT int glatter_glXGetFBConfigAttribSGIX_debug(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigAttribSGIX, "(%p, %p, %d, %p)", (void*)dpy, (void*)config, (int)attribute, (void*)value)
    int rval = glatter_glXGetFBConfigAttribSGIX(dpy, config, attribute, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetFBConfigAttribSGIX_defined
GLATTER_FBLOCK(return, GLX, , GLXFBConfigSGIX, , glXGetFBConfigFromVisualSGIX, (dpy, vis), (Display *dpy, XVisualInfo *vis))
GLATTER_INLINE_OR_NOT GLXFBConfigSGIX glatter_glXGetFBConfigFromVisualSGIX_debug(Display *dpy, XVisualInfo *vis, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigFromVisualSGIX, "(%p, %p)", (void*)dpy, (void*)vis)
    GLXFBConfigSGIX rval = glatter_glXGetFBConfigFromVisualSGIX(dpy, vis);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetFBConfigFromVisualSGIX_defined
GLATTER_FBLOCK(return, GLX, , XVisualInfo *, , glXGetVisualFromFBConfigSGIX, (dpy, config), (Display *dpy, GLXFBConfigSGIX config))
GLATTER_INLINE_OR_NOT XVisualInfo * glatter_glXGetVisualFromFBConfigSGIX_debug(Display *dpy, GLXFBConfigSGIX config, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVisualFromFBConfigSGIX, "(%p, %p)", (void*)dpy, (void*)config)
    XVisualInfo * rval = glatter_glXGetVisualFromFBConfigSGIX(dpy, config);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetVisualFromFBConfigSGIX_defined
#endif // defined(GLX_SGIX_fbconfig)
#if defined(GLX_SGIX_hyperpipe)
GLATTER_FBLOCK(return, GLX, , int, , glXBindHyperpipeSGIX, (dpy, hpId), (Display *dpy, int hpId))
GLATTER_INLINE_OR_NOT int glatter_glXBindHyperpipeSGIX_debug(Display *dpy, int hpId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindHyperpipeSGIX, "(%p, %d)", (void*)dpy, (int)hpId)
    int rval = glatter_glXBindHyperpipeSGIX(dpy, hpId);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXBindHyperpipeSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXDestroyHyperpipeConfigSGIX, (dpy, hpId), (Display *dpy, int hpId))
GLATTER_INLINE_OR_NOT int glatter_glXDestroyHyperpipeConfigSGIX_debug(Display *dpy, int hpId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyHyperpipeConfigSGIX, "(%p, %d)", (void*)dpy, (int)hpId)
    int rval = glatter_glXDestroyHyperpipeConfigSGIX(dpy, hpId);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXDestroyHyperpipeConfigSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXHyperpipeAttribSGIX, (dpy, timeSlice, attrib, size, attribList), (Display *dpy, int timeSlice, int attrib, int size, void *attribList))
GLATTER_INLINE_OR_NOT int glatter_glXHyperpipeAttribSGIX_debug(Display *dpy, int timeSlice, int attrib, int size, void *attribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXHyperpipeAttribSGIX, "(%p, %d, %d, %d, %p)", (void*)dpy, (int)timeSlice, (int)attrib, (int)size, (void*)attribList)
    int rval = glatter_glXHyperpipeAttribSGIX(dpy, timeSlice, attrib, size, attribList);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXHyperpipeAttribSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXHyperpipeConfigSGIX, (dpy, networkId, npipes, cfg, hpId), (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId))
GLATTER_INLINE_OR_NOT int glatter_glXHyperpipeConfigSGIX_debug(Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXHyperpipeConfigSGIX, "(%p, %d, %d, %p, %p)", (void*)dpy, (int)networkId, (int)npipes, (void*)cfg, (void*)hpId)
    int rval = glatter_glXHyperpipeConfigSGIX(dpy, networkId, npipes, cfg, hpId);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXHyperpipeConfigSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXQueryHyperpipeAttribSGIX, (dpy, timeSlice, attrib, size, returnAttribList), (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList))
GLATTER_INLINE_OR_NOT int glatter_glXQueryHyperpipeAttribSGIX_debug(Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryHyperpipeAttribSGIX, "(%p, %d, %d, %d, %p)", (void*)dpy, (int)timeSlice, (int)attrib, (int)size, (void*)returnAttribList)
    int rval = glatter_glXQueryHyperpipeAttribSGIX(dpy, timeSlice, attrib, size, returnAttribList);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryHyperpipeAttribSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXQueryHyperpipeBestAttribSGIX, (dpy, timeSlice, attrib, size, attribList, returnAttribList), (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList))
GLATTER_INLINE_OR_NOT int glatter_glXQueryHyperpipeBestAttribSGIX_debug(Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryHyperpipeBestAttribSGIX, "(%p, %d, %d, %d, %p, %p)", (void*)dpy, (int)timeSlice, (int)attrib, (int)size, (void*)attribList, (void*)returnAttribList)
    int rval = glatter_glXQueryHyperpipeBestAttribSGIX(dpy, timeSlice, attrib, size, attribList, returnAttribList);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryHyperpipeBestAttribSGIX_defined
GLATTER_FBLOCK(return, GLX, , GLXHyperpipeConfigSGIX *, , glXQueryHyperpipeConfigSGIX, (dpy, hpId, npipes), (Display *dpy, int hpId, int *npipes))
GLATTER_INLINE_OR_NOT GLXHyperpipeConfigSGIX * glatter_glXQueryHyperpipeConfigSGIX_debug(Display *dpy, int hpId, int *npipes, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryHyperpipeConfigSGIX, "(%p, %d, %p)", (void*)dpy, (int)hpId, (void*)npipes)
    GLXHyperpipeConfigSGIX * rval = glatter_glXQueryHyperpipeConfigSGIX(dpy, hpId, npipes);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryHyperpipeConfigSGIX_defined
GLATTER_FBLOCK(return, GLX, , GLXHyperpipeNetworkSGIX *, , glXQueryHyperpipeNetworkSGIX, (dpy, npipes), (Display *dpy, int *npipes))
GLATTER_INLINE_OR_NOT GLXHyperpipeNetworkSGIX * glatter_glXQueryHyperpipeNetworkSGIX_debug(Display *dpy, int *npipes, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryHyperpipeNetworkSGIX, "(%p, %p)", (void*)dpy, (void*)npipes)
    GLXHyperpipeNetworkSGIX * rval = glatter_glXQueryHyperpipeNetworkSGIX(dpy, npipes);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryHyperpipeNetworkSGIX_defined
#endif // defined(GLX_SGIX_hyperpipe)
#if defined(GLX_SGIX_pbuffer)
GLATTER_FBLOCK(return, GLX, , GLXPbufferSGIX, , glXCreateGLXPbufferSGIX, (dpy, config, width, height, attrib_list), (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list))
GLATTER_INLINE_OR_NOT GLXPbufferSGIX glatter_glXCreateGLXPbufferSGIX_debug(Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXPbufferSGIX, "(%p, %p, %u, %u, %p)", (void*)dpy, (void*)config, (unsigned int)width, (unsigned int)height, (void*)attrib_list)
    GLXPbufferSGIX rval = glatter_glXCreateGLXPbufferSGIX(dpy, config, width, height, attrib_list);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateGLXPbufferSGIX_defined
GLATTER_FBLOCK(, GLX, , void, , glXDestroyGLXPbufferSGIX, (dpy, pbuf), (Display *dpy, GLXPbufferSGIX pbuf))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyGLXPbufferSGIX_debug(Display *dpy, GLXPbufferSGIX pbuf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyGLXPbufferSGIX, "(%p, %s)", (void*)dpy, GET_PRS(pbuf))
    glatter_glXDestroyGLXPbufferSGIX(dpy, pbuf);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyGLXPbufferSGIX_defined
GLATTER_FBLOCK(, GLX, , void, , glXGetSelectedEventSGIX, (dpy, drawable, mask), (Display *dpy, GLXDrawable drawable, unsigned long *mask))
GLATTER_INLINE_OR_NOT void glatter_glXGetSelectedEventSGIX_debug(Display *dpy, GLXDrawable drawable, unsigned long *mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSelectedEventSGIX, "(%p, %s, %p)", (void*)dpy, GET_PRS(drawable), (void*)mask)
    glatter_glXGetSelectedEventSGIX(dpy, drawable, mask);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXGetSelectedEventSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXQueryGLXPbufferSGIX, (dpy, pbuf, attribute, value), (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value))
GLATTER_INLINE_OR_NOT int glatter_glXQueryGLXPbufferSGIX_debug(Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryGLXPbufferSGIX, "(%p, %s, %d, %p)", (void*)dpy, GET_PRS(pbuf), (int)attribute, (void*)value)
    int rval = glatter_glXQueryGLXPbufferSGIX(dpy, pbuf, attribute, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryGLXPbufferSGIX_defined
GLATTER_FBLOCK(, GLX, , void, , glXSelectEventSGIX, (dpy, drawable, mask), (Display *dpy, GLXDrawable drawable, unsigned long mask))
GLATTER_INLINE_OR_NOT void glatter_glXSelectEventSGIX_debug(Display *dpy, GLXDrawable drawable, unsigned long mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSelectEventSGIX, "(%p, %s, %lu)", (void*)dpy, GET_PRS(drawable), (unsigned long)mask)
    glatter_glXSelectEventSGIX(dpy, drawable, mask);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXSelectEventSGIX_defined
#endif // defined(GLX_SGIX_pbuffer)
#if defined(GLX_SGIX_swap_barrier)
GLATTER_FBLOCK(, GLX, , void, , glXBindSwapBarrierSGIX, (dpy, drawable, barrier), (Display *dpy, GLXDrawable drawable, int barrier))
GLATTER_INLINE_OR_NOT void glatter_glXBindSwapBarrierSGIX_debug(Display *dpy, GLXDrawable drawable, int barrier, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindSwapBarrierSGIX, "(%p, %s, %d)", (void*)dpy, GET_PRS(drawable), (int)barrier)
    glatter_glXBindSwapBarrierSGIX(dpy, drawable, barrier);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXBindSwapBarrierSGIX_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXQueryMaxSwapBarriersSGIX, (dpy, screen, max), (Display *dpy, int screen, int *max))
GLATTER_INLINE_OR_NOT Bool glatter_glXQueryMaxSwapBarriersSGIX_debug(Display *dpy, int screen, int *max, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryMaxSwapBarriersSGIX, "(%p, %d, %p)", (void*)dpy, (int)screen, (void*)max)
    Bool rval = glatter_glXQueryMaxSwapBarriersSGIX(dpy, screen, max);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryMaxSwapBarriersSGIX_defined
#endif // defined(GLX_SGIX_swap_barrier)
#if defined(GLX_SGIX_swap_group)
GLATTER_FBLOCK(, GLX, , void, , glXJoinSwapGroupSGIX, (dpy, drawable, member), (Display *dpy, GLXDrawable drawable, GLXDrawable member))
GLATTER_INLINE_OR_NOT void glatter_glXJoinSwapGroupSGIX_debug(Display *dpy, GLXDrawable drawable, GLXDrawable member, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXJoinSwapGroupSGIX, "(%p, %s, %s)", (void*)dpy, GET_PRS(drawable), GET_PRS(member))
    glatter_glXJoinSwapGroupSGIX(dpy, drawable, member);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXJoinSwapGroupSGIX_defined
#endif // defined(GLX_SGIX_swap_group)
#if defined(GLX_SGIX_video_resize)
GLATTER_FBLOCK(return, GLX, , int, , glXBindChannelToWindowSGIX, (display, screen, channel, window), (Display *display, int screen, int channel, Window window))
GLATTER_INLINE_OR_NOT int glatter_glXBindChannelToWindowSGIX_debug(Display *display, int screen, int channel, Window window, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXBindChannelToWindowSGIX, "(%p, %d, %d, %s)", (void*)display, (int)screen, (int)channel, GET_PRS(window))
    int rval = glatter_glXBindChannelToWindowSGIX(display, screen, channel, window);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXBindChannelToWindowSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXChannelRectSGIX, (display, screen, channel, x, y, w, h), (Display *display, int screen, int channel, int x, int y, int w, int h))
GLATTER_INLINE_OR_NOT int glatter_glXChannelRectSGIX_debug(Display *display, int screen, int channel, int x, int y, int w, int h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXChannelRectSGIX, "(%p, %d, %d, %d, %d, %d, %d)", (void*)display, (int)screen, (int)channel, (int)x, (int)y, (int)w, (int)h)
    int rval = glatter_glXChannelRectSGIX(display, screen, channel, x, y, w, h);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXChannelRectSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXChannelRectSyncSGIX, (display, screen, channel, synctype), (Display *display, int screen, int channel, GLenum synctype))
GLATTER_INLINE_OR_NOT int glatter_glXChannelRectSyncSGIX_debug(Display *display, int screen, int channel, GLenum synctype, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXChannelRectSyncSGIX, "(%p, %d, %d, %s)", (void*)display, (int)screen, (int)channel, enum_to_string_GL(synctype))
    int rval = glatter_glXChannelRectSyncSGIX(display, screen, channel, synctype);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXChannelRectSyncSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXQueryChannelDeltasSGIX, (display, screen, channel, x, y, w, h), (Display *display, int screen, int channel, int *x, int *y, int *w, int *h))
GLATTER_INLINE_OR_NOT int glatter_glXQueryChannelDeltasSGIX_debug(Display *display, int screen, int channel, int *x, int *y, int *w, int *h, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryChannelDeltasSGIX, "(%p, %d, %d, %p, %p, %p, %p)", (void*)display, (int)screen, (int)channel, (void*)x, (void*)y, (void*)w, (void*)h)
    int rval = glatter_glXQueryChannelDeltasSGIX(display, screen, channel, x, y, w, h);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryChannelDeltasSGIX_defined
GLATTER_FBLOCK(return, GLX, , int, , glXQueryChannelRectSGIX, (display, screen, channel, dx, dy, dw, dh), (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh))
GLATTER_INLINE_OR_NOT int glatter_glXQueryChannelRectSGIX_debug(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryChannelRectSGIX, "(%p, %d, %d, %p, %p, %p, %p)", (void*)display, (int)screen, (int)channel, (void*)dx, (void*)dy, (void*)dw, (void*)dh)
    int rval = glatter_glXQueryChannelRectSGIX(display, screen, channel, dx, dy, dw, dh);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryChannelRectSGIX_defined
#endif // defined(GLX_SGIX_video_resize)
#if defined(GLX_SGIX_video_source)
#if defined(_VL_H)
GLATTER_FBLOCK(return, GLX, , GLXVideoSourceSGIX, , glXCreateGLXVideoSourceSGIX, (display, screen, server, path, nodeClass, drainNode), (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode))
GLATTER_INLINE_OR_NOT GLXVideoSourceSGIX glatter_glXCreateGLXVideoSourceSGIX_debug(Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateGLXVideoSourceSGIX, "(%p, %d, %s, %s, %d, %s)", (void*)display, (int)screen, GET_PRS(server), GET_PRS(path), (int)nodeClass, GET_PRS(drainNode))
    GLXVideoSourceSGIX rval = glatter_glXCreateGLXVideoSourceSGIX(display, screen, server, path, nodeClass, drainNode);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateGLXVideoSourceSGIX_defined
GLATTER_FBLOCK(, GLX, , void, , glXDestroyGLXVideoSourceSGIX, (dpy, glxvideosource), (Display *dpy, GLXVideoSourceSGIX glxvideosource))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyGLXVideoSourceSGIX_debug(Display *dpy, GLXVideoSourceSGIX glxvideosource, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyGLXVideoSourceSGIX, "(%p, %s)", (void*)dpy, GET_PRS(glxvideosource))
    glatter_glXDestroyGLXVideoSourceSGIX(dpy, glxvideosource);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyGLXVideoSourceSGIX_defined
#endif // defined(_VL_H)
#endif // defined(GLX_SGIX_video_source)
#if defined(GLX_SGI_cushion)
GLATTER_FBLOCK(, GLX, , void, , glXCushionSGI, (dpy, window, cushion), (Display *dpy, Window window, float cushion))
GLATTER_INLINE_OR_NOT void glatter_glXCushionSGI_debug(Display *dpy, Window window, float cushion, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCushionSGI, "(%p, %s, %f)", (void*)dpy, GET_PRS(window), (float)cushion)
    glatter_glXCushionSGI(dpy, window, cushion);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXCushionSGI_defined
#endif // defined(GLX_SGI_cushion)
#if defined(GLX_SGI_make_current_read)
GLATTER_FBLOCK(return, GLX, , GLXDrawable, , glXGetCurrentReadDrawableSGI, (), (void))
GLATTER_INLINE_OR_NOT GLXDrawable glatter_glXGetCurrentReadDrawableSGI_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentReadDrawableSGI, "()")
    GLXDrawable rval = glatter_glXGetCurrentReadDrawableSGI();
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetCurrentReadDrawableSGI_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXMakeCurrentReadSGI, (dpy, draw, read, ctx), (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx))
GLATTER_INLINE_OR_NOT Bool glatter_glXMakeCurrentReadSGI_debug(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXMakeCurrentReadSGI, "(%p, %s, %s, %p)", (void*)dpy, GET_PRS(draw), GET_PRS(read), (void*)ctx)
    Bool rval = glatter_glXMakeCurrentReadSGI(dpy, draw, read, ctx);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXMakeCurrentReadSGI_defined
#endif // defined(GLX_SGI_make_current_read)
#if defined(GLX_SGI_swap_control)
GLATTER_FBLOCK(return, GLX, , int, , glXSwapIntervalSGI, (interval), (int interval))
GLATTER_INLINE_OR_NOT int glatter_glXSwapIntervalSGI_debug(int interval, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSwapIntervalSGI, "(%d)", (int)interval)
    int rval = glatter_glXSwapIntervalSGI(interval);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXSwapIntervalSGI_defined
#endif // defined(GLX_SGI_swap_control)
#if defined(GLX_SGI_video_sync)
GLATTER_FBLOCK(return, GLX, , int, , glXGetVideoSyncSGI, (count), (unsigned int *count))
GLATTER_INLINE_OR_NOT int glatter_glXGetVideoSyncSGI_debug(unsigned int *count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVideoSyncSGI, "(%p)", (void*)count)
    int rval = glatter_glXGetVideoSyncSGI(count);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetVideoSyncSGI_defined
GLATTER_FBLOCK(return, GLX, , int, , glXWaitVideoSyncSGI, (divisor, remainder, count), (int divisor, int remainder, unsigned int *count))
GLATTER_INLINE_OR_NOT int glatter_glXWaitVideoSyncSGI_debug(int divisor, int remainder, unsigned int *count, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXWaitVideoSyncSGI, "(%d, %d, %p)", (int)divisor, (int)remainder, (void*)count)
    int rval = glatter_glXWaitVideoSyncSGI(divisor, remainder, count);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXWaitVideoSyncSGI_defined
#endif // defined(GLX_SGI_video_sync)
#if defined(GLX_SUN_get_transparent_index)
GLATTER_FBLOCK(return, GLX, , Status, , glXGetTransparentIndexSUN, (dpy, overlay, underlay, pTransparentIndex), (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex))
GLATTER_INLINE_OR_NOT Status glatter_glXGetTransparentIndexSUN_debug(Display *dpy, Window overlay, Window underlay, long *pTransparentIndex, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetTransparentIndexSUN, "(%p, %s, %s, %p)", (void*)dpy, GET_PRS(overlay), GET_PRS(underlay), (void*)pTransparentIndex)
    Status rval = glatter_glXGetTransparentIndexSUN(dpy, overlay, underlay, pTransparentIndex);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetTransparentIndexSUN_defined
#endif // defined(GLX_SUN_get_transparent_index)
#if defined(GLX_VERSION_1_3)
#ifndef glXChooseFBConfig_defined
GLATTER_FBLOCK(return, GLX, , GLXFBConfig *, , glXChooseFBConfig, (dpy, screen, attrib_list, nelements), (Display *dpy, int screen, const int *attrib_list, int *nelements))
GLATTER_INLINE_OR_NOT GLXFBConfig * glatter_glXChooseFBConfig_debug(Display *dpy, int screen, const int *attrib_list, int *nelements, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXChooseFBConfig, "(%p, %d, %p, %p)", (void*)dpy, (int)screen, (void*)attrib_list, (void*)nelements)
    GLXFBConfig * rval = glatter_glXChooseFBConfig(dpy, screen, attrib_list, nelements);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXChooseFBConfig_defined
#endif
#ifndef glXCreateNewContext_defined
GLATTER_FBLOCK(return, GLX, , GLXContext, , glXCreateNewContext, (dpy, config, render_type, share_list, direct), (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct))
GLATTER_INLINE_OR_NOT GLXContext glatter_glXCreateNewContext_debug(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateNewContext, "(%p, %p, %d, %p, %s)", (void*)dpy, (void*)config, (int)render_type, (void*)share_list, GET_PRS(direct))
    GLXContext rval = glatter_glXCreateNewContext(dpy, config, render_type, share_list, direct);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateNewContext_defined
#endif
#ifndef glXCreatePbuffer_defined
GLATTER_FBLOCK(return, GLX, , GLXPbuffer, , glXCreatePbuffer, (dpy, config, attrib_list), (Display *dpy, GLXFBConfig config, const int *attrib_list))
GLATTER_INLINE_OR_NOT GLXPbuffer glatter_glXCreatePbuffer_debug(Display *dpy, GLXFBConfig config, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreatePbuffer, "(%p, %p, %p)", (void*)dpy, (void*)config, (void*)attrib_list)
    GLXPbuffer rval = glatter_glXCreatePbuffer(dpy, config, attrib_list);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreatePbuffer_defined
#endif
#ifndef glXCreatePixmap_defined
GLATTER_FBLOCK(return, GLX, , GLXPixmap, , glXCreatePixmap, (dpy, config, pixmap, attrib_list), (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list))
GLATTER_INLINE_OR_NOT GLXPixmap glatter_glXCreatePixmap_debug(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreatePixmap, "(%p, %p, %s, %p)", (void*)dpy, (void*)config, GET_PRS(pixmap), (void*)attrib_list)
    GLXPixmap rval = glatter_glXCreatePixmap(dpy, config, pixmap, attrib_list);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreatePixmap_defined
#endif
#ifndef glXCreateWindow_defined
GLATTER_FBLOCK(return, GLX, , GLXWindow, , glXCreateWindow, (dpy, config, win, attrib_list), (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list))
GLATTER_INLINE_OR_NOT GLXWindow glatter_glXCreateWindow_debug(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXCreateWindow, "(%p, %p, %s, %p)", (void*)dpy, (void*)config, GET_PRS(win), (void*)attrib_list)
    GLXWindow rval = glatter_glXCreateWindow(dpy, config, win, attrib_list);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXCreateWindow_defined
#endif
#ifndef glXDestroyPbuffer_defined
GLATTER_FBLOCK(, GLX, , void, , glXDestroyPbuffer, (dpy, pbuf), (Display *dpy, GLXPbuffer pbuf))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyPbuffer_debug(Display *dpy, GLXPbuffer pbuf, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyPbuffer, "(%p, %s)", (void*)dpy, GET_PRS(pbuf))
    glatter_glXDestroyPbuffer(dpy, pbuf);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyPbuffer_defined
#endif
#ifndef glXDestroyPixmap_defined
GLATTER_FBLOCK(, GLX, , void, , glXDestroyPixmap, (dpy, pixmap), (Display *dpy, GLXPixmap pixmap))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyPixmap_debug(Display *dpy, GLXPixmap pixmap, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyPixmap, "(%p, %s)", (void*)dpy, GET_PRS(pixmap))
    glatter_glXDestroyPixmap(dpy, pixmap);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyPixmap_defined
#endif
#ifndef glXDestroyWindow_defined
GLATTER_FBLOCK(, GLX, , void, , glXDestroyWindow, (dpy, win), (Display *dpy, GLXWindow win))
GLATTER_INLINE_OR_NOT void glatter_glXDestroyWindow_debug(Display *dpy, GLXWindow win, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXDestroyWindow, "(%p, %s)", (void*)dpy, GET_PRS(win))
    glatter_glXDestroyWindow(dpy, win);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXDestroyWindow_defined
#endif
#ifndef glXGetCurrentReadDrawable_defined
GLATTER_FBLOCK(return, GLX, , GLXDrawable, , glXGetCurrentReadDrawable, (), (void))
GLATTER_INLINE_OR_NOT GLXDrawable glatter_glXGetCurrentReadDrawable_debug(const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetCurrentReadDrawable, "()")
    GLXDrawable rval = glatter_glXGetCurrentReadDrawable();
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetCurrentReadDrawable_defined
#endif
#ifndef glXGetFBConfigAttrib_defined
GLATTER_FBLOCK(return, GLX, , int, , glXGetFBConfigAttrib, (dpy, config, attribute, value), (Display *dpy, GLXFBConfig config, int attribute, int *value))
GLATTER_INLINE_OR_NOT int glatter_glXGetFBConfigAttrib_debug(Display *dpy, GLXFBConfig config, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigAttrib, "(%p, %p, %d, %p)", (void*)dpy, (void*)config, (int)attribute, (void*)value)
    int rval = glatter_glXGetFBConfigAttrib(dpy, config, attribute, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetFBConfigAttrib_defined
#endif
#ifndef glXGetFBConfigs_defined
GLATTER_FBLOCK(return, GLX, , GLXFBConfig *, , glXGetFBConfigs, (dpy, screen, nelements), (Display *dpy, int screen, int *nelements))
GLATTER_INLINE_OR_NOT GLXFBConfig * glatter_glXGetFBConfigs_debug(Display *dpy, int screen, int *nelements, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetFBConfigs, "(%p, %d, %p)", (void*)dpy, (int)screen, (void*)nelements)
    GLXFBConfig * rval = glatter_glXGetFBConfigs(dpy, screen, nelements);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetFBConfigs_defined
#endif
#ifndef glXGetSelectedEvent_defined
GLATTER_FBLOCK(, GLX, , void, , glXGetSelectedEvent, (dpy, draw, event_mask), (Display *dpy, GLXDrawable draw, unsigned long *event_mask))
GLATTER_INLINE_OR_NOT void glatter_glXGetSelectedEvent_debug(Display *dpy, GLXDrawable draw, unsigned long *event_mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetSelectedEvent, "(%p, %s, %p)", (void*)dpy, GET_PRS(draw), (void*)event_mask)
    glatter_glXGetSelectedEvent(dpy, draw, event_mask);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXGetSelectedEvent_defined
#endif
#ifndef glXGetVisualFromFBConfig_defined
GLATTER_FBLOCK(return, GLX, , XVisualInfo *, , glXGetVisualFromFBConfig, (dpy, config), (Display *dpy, GLXFBConfig config))
GLATTER_INLINE_OR_NOT XVisualInfo * glatter_glXGetVisualFromFBConfig_debug(Display *dpy, GLXFBConfig config, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetVisualFromFBConfig, "(%p, %p)", (void*)dpy, (void*)config)
    XVisualInfo * rval = glatter_glXGetVisualFromFBConfig(dpy, config);
    GLATTER_RBLOCK("%p\n", (void*)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetVisualFromFBConfig_defined
#endif
#ifndef glXMakeContextCurrent_defined
GLATTER_FBLOCK(return, GLX, , Bool, , glXMakeContextCurrent, (dpy, draw, read, ctx), (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx))
GLATTER_INLINE_OR_NOT Bool glatter_glXMakeContextCurrent_debug(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXMakeContextCurrent, "(%p, %s, %s, %p)", (void*)dpy, GET_PRS(draw), GET_PRS(read), (void*)ctx)
    Bool rval = glatter_glXMakeContextCurrent(dpy, draw, read, ctx);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXMakeContextCurrent_defined
#endif
#ifndef glXQueryContext_defined
GLATTER_FBLOCK(return, GLX, , int, , glXQueryContext, (dpy, ctx, attribute, value), (Display *dpy, GLXContext ctx, int attribute, int *value))
GLATTER_INLINE_OR_NOT int glatter_glXQueryContext_debug(Display *dpy, GLXContext ctx, int attribute, int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryContext, "(%p, %p, %d, %p)", (void*)dpy, (void*)ctx, (int)attribute, (void*)value)
    int rval = glatter_glXQueryContext(dpy, ctx, attribute, value);
    GLATTER_RBLOCK("%d\n", (int)rval);
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXQueryContext_defined
#endif
#ifndef glXQueryDrawable_defined
GLATTER_FBLOCK(, GLX, , void, , glXQueryDrawable, (dpy, draw, attribute, value), (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value))
GLATTER_INLINE_OR_NOT void glatter_glXQueryDrawable_debug(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXQueryDrawable, "(%p, %s, %d, %p)", (void*)dpy, GET_PRS(draw), (int)attribute, (void*)value)
    glatter_glXQueryDrawable(dpy, draw, attribute, value);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXQueryDrawable_defined
#endif
#ifndef glXSelectEvent_defined
GLATTER_FBLOCK(, GLX, , void, , glXSelectEvent, (dpy, draw, event_mask), (Display *dpy, GLXDrawable draw, unsigned long event_mask))
GLATTER_INLINE_OR_NOT void glatter_glXSelectEvent_debug(Display *dpy, GLXDrawable draw, unsigned long event_mask, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXSelectEvent, "(%p, %s, %lu)", (void*)dpy, GET_PRS(draw), (unsigned long)event_mask)
    glatter_glXSelectEvent(dpy, draw, event_mask);
    GLATTER_CHECK_ERROR(GLX, file, line)
}
#define glXSelectEvent_defined
#endif
#endif // defined(GLX_VERSION_1_3)
#if defined(GLX_VERSION_1_4)
GLATTER_FBLOCK(return, GLX, , __GLXextFuncPtr, , glXGetProcAddress, (procName), (const GLubyte *procName))
GLATTER_INLINE_OR_NOT __GLXextFuncPtr glatter_glXGetProcAddress_debug(const GLubyte *procName, const char* file, int line)
{
    GLATTER_DBLOCK(file, line, glXGetProcAddress, "(%p)", (void*)procName)
    __GLXextFuncPtr rval = glatter_glXGetProcAddress(procName);
    GLATTER_RBLOCK("%s\n", GET_PRS(rval));
    GLATTER_CHECK_ERROR(GLX, file, line)
    return rval;
}
#define glXGetProcAddress_defined
#endif // defined(__glx_glxext_h_)
#endif // defined(GLX_VERSION_1_4)
#endif // GLATTER_GLX

