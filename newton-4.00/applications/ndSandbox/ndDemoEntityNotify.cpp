/* Copyright (c) <2003-2022> <Newton Game Dynamics>
* 
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
* 
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely
*/

#include "ndSandboxStdafx.h"
#include "ndDemoEntityNotify.h"

ndDemoEntityNotify::ndDemoEntityNotify(ndDemoEntityManager* const manager, const ndSharedPtr<ndRenderSceneNode>& entity, ndBodyKinematic* const parentBody, ndFloat32 gravity)
	:ndModelBodyNotify(parentBody, ndVector(0.0f, gravity, 0.0f, 0.0f))
	,m_manager(manager)
	,m_entity(entity)
	,m_transform()
{
}

ndDemoEntityNotify::ndDemoEntityNotify(const ndDemoEntityNotify& notify)
	:ndModelBodyNotify(notify)
	,m_manager(notify.m_manager)
	,m_entity(notify.m_entity)
	,m_transform()
{
}

ndDemoEntityNotify::~ndDemoEntityNotify()
{
}

void ndDemoEntityNotify::OnTransform(ndInt32, const ndMatrix& matrix)
{
	// apply this transformation matrix to the application user data.
	if (*m_entity)
	{
		ndBody* const body = GetBody();
		m_transform.m_position = matrix.m_posit;
		m_transform.m_rotation = body->GetRotation();
	}

	//if (!CheckInWorld(matrix))
	//{
	//	RemoveBody();
	//}
}

//void ndDemoEntityNotify::RemoveBody()
//{
//	// check world bounds
//	ndBody* const body = GetBody();
//	ndPhysicsWorld* const world = m_manager->GetWorld();
//	world->RemoveBody(body);
//}

ndBindingRagdollEntityNotify::ndBindingRagdollEntityNotify(ndDemoEntityManager* const manager, const ndSharedPtr<ndRenderSceneNode>& entity, ndBodyDynamic* const parentBody, ndFloat32 capSpeed)
	:ndDemoEntityNotify(manager, entity, parentBody)
	,m_bindMatrix(ndGetIdentityMatrix())
	,m_capSpeed(capSpeed)
{
	ndAssert(0);
	//if (m_parentBody)
	//{
	//	ndDemoEntityNotify* const notify = (ndDemoEntityNotify*)parentBody->GetNotifyCallback();
	//	const ndDemoEntity* const parentEntity = *notify->m_entity;
	//
	//	ndMatrix matrix(ndGetIdentityMatrix());
	//	for (const ndDemoEntity* parent = entity->GetParent(); parent != parentEntity; parent = parent->GetParent())
	//	{
	//		const ndMatrix parentMatrix(parent->GetCurrentMatrix());
	//		matrix = matrix * parentMatrix;
	//	}
	//	m_bindMatrix = matrix;
	//}
	//else
	//{
	//	//const ndMatrix parentMatrix(entity->GetParent()->CalculateGlobalMatrix());
	//	const ndMatrix parentMatrix(entity->GetParent() ? entity->GetParent()->CalculateGlobalMatrix() : ndGetIdentityMatrix());
	//	m_bindMatrix = parentMatrix.OrthoInverse();
	//}
}

ndBindingRagdollEntityNotify::~ndBindingRagdollEntityNotify()
{
}

void ndBindingRagdollEntityNotify::OnTransform(ndInt32, const ndMatrix& matrix)
{
	if (!m_parentBody)
	{
		const ndMatrix localMatrix(matrix * m_bindMatrix);
		const ndQuaternion rot(localMatrix);
		m_entity->SetMatrix(rot, localMatrix.m_posit);
	}
	else
	{
		const ndMatrix parentMatrix(m_bindMatrix * m_parentBody->GetMatrix());
		const ndMatrix localMatrix(matrix * parentMatrix.OrthoInverse());

		const ndQuaternion rot(localMatrix);
		m_entity->SetMatrix(rot, localMatrix.m_posit);
	}

	//if (!CheckInWorld(matrix))
	//{
	//	RemoveBody();
	//}
}

void ndBindingRagdollEntityNotify::OnApplyExternalForce(ndInt32 thread, ndFloat32 timestep)
{
	ndDemoEntityNotify::OnApplyExternalForce(thread, timestep);

	// Clamp huge angular and linear velocities generated by high speed collisions
	ndBodyKinematic* const body = GetBody()->GetAsBodyKinematic();
	ndAssert(body && body->GetInvMass() > 0.0f);

	// clamp excessive velocities.
	ndVector omega(body->GetOmega());
	ndVector veloc(body->GetVelocity());
	ndFloat32 omega2(omega.DotProduct(omega).GetScalar());
	if (omega2 > m_capSpeed * m_capSpeed)
	{
		omega = omega.Normalize().Scale(m_capSpeed);
		body->SetOmega(omega);
	}

	ndFloat32 veloc2(veloc.DotProduct(veloc).GetScalar());
	if (veloc2 > m_capSpeed * m_capSpeed)
	{
		veloc = veloc.Normalize().Scale(m_capSpeed);
		body->SetVelocity(veloc);
	}
}

