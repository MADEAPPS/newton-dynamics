/* Copyright (c) <2003-2022> <Newton Game Dynamics>
* 
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
* 
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely
*/
#version 450
#define WORKGROUP_SIZE 128
layout (local_size_x = WORKGROUP_SIZE) in;

layout(std140, binding = 0) uniform UniformBufferObject 
{
    int m_inputSize;
    int m_inputStart;
    int m_outputSize;
    int m_outputStart;
    int m_workBufferSize;
    
    int m_paramStart;
    int m_paramBiasStart;
    int m_paramWeightStart;
    int m_paramWeightBlockSize;
};

layout(std430, binding = 1) readonly buffer inputBuffer
{
    float m_networkParameters[];
};

layout(std430, binding = 2) buffer outputBuffer
{
    float m_workingBuffer[];
};

shared float reductionBuffer [WORKGROUP_SIZE];

// perform a full vector * matrix operation
void main() 
{
    uint paramBatchSize = gl_WorkGroupID.x * m_paramWeightBlockSize;
    uint inputOffset = paramBatchSize + m_paramStart + m_inputStart;
    uint outPutOffset = paramBatchSize + m_paramStart + m_outputStart;

    uint workBatchSize = gl_WorkGroupID.x * m_workBufferSize;
    uint biasOffset = workBatchSize + m_paramStart + m_paramBiasStart;
    for (uint index = gl_LocalInvocationID.x; index < m_inputSize; index += gl_WorkGroupSize.x)
    {
        reductionBuffer[index] = m_networkParameters[inputOffset + index];
        float acc = m_networkParameters[biasOffset + index];
        uint weightOffset = m_paramStart + m_paramWeightStart;
        memoryBarrierShared(); 
        barrier();
        for (uint i = 0; i < m_outputSize; i ++)
        {
            float scale = reductionBuffer[i];
            acc += scale * m_networkParameters[weightOffset + index];
            weightOffset += gl_WorkGroupSize.x;
        }
        m_workingBuffer[outPutOffset + index] = acc;
    }
}