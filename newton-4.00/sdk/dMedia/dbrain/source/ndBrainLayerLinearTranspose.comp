/* Copyright (c) <2003-2022> <Newton Game Dynamics>
* 
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
* 
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely
*/
#version 450
#define WORKGROUP_SIZE 128
layout (local_size_x = WORKGROUP_SIZE) in;

layout(std140, binding = 0) uniform UniformBufferObject 
{
    int m_matrixRows;
    int m_matrixColumns;
    int m_matrixColumnsStride;

    int m_paramStart;
    int m_inputStart;
    int m_outputStart;
    int m_workBufferSize;
};

layout(std430, binding = 1) readonly buffer inputBuffer
{
    float m_networkParameters[];
};

layout(std430, binding = 2) buffer outputBuffer
{
    float m_workingBuffer[];
};

//shared float reductionBuffer [WORKGROUP_SIZE];

// perform a full vector * matrix operation
void main() 
{
    //uint paramOffset = gl_WorkGroupID.x * m_paramStart;
    //uint inputOffset = gl_WorkGroupID.x * m_paramStart;
    //uint outputOffset = gl_WorkGroupID.x * m_workBufferSize * m_paramStart + m_outputStart;
    //for (uint columnBase = gl_LocalInvocationID.x; columnBase < m_matrixColumns; columnBase += gl_WorkGroupSize.x)
    //{
    //    float partialSum = 0.0f;
    //    uint offset = paramOffset;
    //    for (uint rowIndex = 0; rowIndex < m_matrixRows; rowIndex ++)
    //    {
    //        //float inpuColumScale = m_workingBuffer[m_inputStart + columnBase];
    //        //partialSum += inpuColumScale * m_networkParameters[offset + rowIndex];
    //
    //        offset += m_matrixColumnsStride;
    //    }
    //    partialSum += m_networkParameters[offset + columnBase];
    //
    //    m_workingBuffer[outputOffset + columnBase] = partialSum;
    //}
}